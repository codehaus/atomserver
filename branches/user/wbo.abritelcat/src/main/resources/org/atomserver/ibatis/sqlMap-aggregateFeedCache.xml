<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<!DOCTYPE sqlMap PUBLIC "-//iBATIS.com//DTD SQL Map 2.0//EN" "http://www.ibatis.com/dtd/sql-map-2.dtd">
<!--
 Copyright (c) 2007 HomeAway, Inc.
  All rights reserved.  http://www.atomserver.org

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<sqlMap>

    <!-- Queris on AggregateFeedTimestamp table -->

    <!-- Inner select of the aggregate feed query from AggregateFeedTimestamp -->
    <sql id="SELECT_modifiedAggregateEntriesUsingCache">
        SELECT <include refid="paginationPrefix"/>
               recentlyChangedEntries.Term AS AggregateEntryId,
               recentlyChangedEntries.UpdateTimestamp
          <!-- we join the view VW_EntryWithCategory with AggregateFeedTimestamps Cache -->
          FROM vw_EntryWithCategory recentlyChangedEntries <include refid="WITH_NOEXPAND"/>
          INNER JOIN AggregateFeedTimestamp timestampCache
            ON recentlyChangedEntries.Scheme = #collection#
            AND recentlyChangedEntries.Term = timestampCache.Term
            AND recentlyChangedEntries.UpdateTimestamp = timestampCache.UpdateTimestampValue
        <isNotNull property="startIndex">
           AND recentlyChangedEntries.UpdateTimestamp > CAST(#startIndex# AS <include refid="timestampType"/>)
            <isNotEqual property="endIndex" compareValue="-1">
               AND recentlyChangedEntries.UpdateTimestamp &lt;= CAST(#endIndex# AS <include refid="timestampType"/>)
            </isNotEqual>
        </isNotNull>

        <isNotNull property="updatedMin" >
           AND recentlyChangedEntries.UpdateDate >= #updatedMin#
        </isNotNull>
        <isNotNull property="updatedMax">
            <![CDATA[ AND recentlyChangedEntries.UpdateDate < #updatedMax# ]]>
        </isNotNull>

        <isNotNull property="latencySeconds">
           AND (
            <isEqual property="dbType" compareValue="hsql">
             DATEDIFF('ss', recentlyChangedEntries.UpdateDate, NOW()) >= $latencySeconds$
            </isEqual>
            <isEqual property="dbType" compareValue="sqlserver">
             DATEADD(s, -1 * $latencySeconds$, GETDATE()) >= recentlyChangedEntries.UpdateDate
            </isEqual>
            <isEqual property="dbType" compareValue="postgres">
             NOW() - interval '$latencySeconds$ seconds' >= recentlyChangedEntries.UpdateDate
            </isEqual>
            )
        </isNotNull>

        <isNotNull property="language">
           AND ((recentlyChangedEntries.LanCode = #language# AND recentlyChangedEntries.CountryCode = #country#)
                OR (recentlyChangedEntries.LanCode = '**' AND recentlyChangedEntries.CountryCode = '**'))
        </isNotNull>
           <!-- If any joinCachedFeedId were specified on the query, we need to limit our rows here
                to only include the right rows. -->
        <isNotNull property="joinWorkspaces">
           AND recentlyChangedEntries.Workspace IN
           <iterate property="joinWorkspaces" open="(" close=")" conjunction=",">
               #joinWorkspaces[]#
           </iterate>
        </isNotNull>
        <isNotNull property="cachedfeedid">
           AND timestampCache.CachedFeedId = #cachedfeedid#
        </isNotNull>
        <isNotNull property="entryId">
           AND recentlyChangedEntries.Term = #entryId#
        </isNotNull>
        <isNotNull property="categoryQuerySql">
          <!-- matchineSiblingEntries was join again to get the EntryStoreId to join against EntryCategory.
               Although this is an extra join, the performance does not seems to have suffered in the performance tests -->
          INNER JOIN vw_EntryWithCategory matchingSiblingEntries ON recentlyChangedEntries.Term = matchingSiblingEntries.Term
          AND matchingSiblingEntries.Scheme = #collection#
          LEFT OUTER JOIN EntryCategory searchCategories
            ON searchCategories.EntryStoreId = matchingSiblingEntries.EntryStoreId
          GROUP BY recentlyChangedEntries.UpdateTimestamp, recentlyChangedEntries.Term
          HAVING $categoryQuerySql$
        </isNotNull>
         ORDER BY recentlyChangedEntries.UpdateTimestamp ASC
        <include refid="paginationSuffix"/>
    </sql>


    <select id="selectAggregateEntriesUsingCache" parameterClass="map" resultMap="entryResult">
        SELECT entries.EntryStoreId AS EntryStoreId,
               entries.Workspace AS Workspace,
               entries.Collection AS Collection,
               entries.LanCode AS LanCode,
               entries.CountryCode AS CountryCode,
               entries.EntryId AS EntryId,
               entries.UpdateDate AS UpdateDate,
               entries.CreateDate AS CreateDate,
               CAST(entries.UpdateTimestamp AS BIGINT) AS UpdateTimestamp,
               entries.DeleteFlag AS DeleteFlag,
               entries.RevisionNum AS RevisionNum,
               entries.ContentHashCode As contentHashCode,
               categories.Scheme AS Scheme,
               categories.Term AS Term,
               categories.Term AS Label
          FROM
        (
        <!-- This inner query determines the aggregate entries to pull - now we need to join in the
             EntryStore data and EntryCategory data to get the data set to return -->
            <include refid="SELECT_modifiedAggregateEntriesUsingCache"/>
        ) aggregateEntryIds
        <!-- This join to "candidates" re-selects all of the members of the aggregates -->
         INNER JOIN vw_EntryWithCategory candidates <include refid="WITH_NOEXPAND"/>
            ON candidates.Scheme = #collection#
           AND candidates.Term = aggregateEntryIds.AggregateEntryId
        <isNotNull property="language">
           AND ((candidates.LanCode = #language# AND candidates.CountryCode = #country#)
                OR (candidates.LanCode = '**' AND candidates.CountryCode = '**'))
        </isNotNull>
        <!-- This join to "entries" pulls in the EntryStore data, and filters out any candidates
             that were outside of the set of join workspaces requested for the feed -->
         INNER JOIN EntryStore entries
            ON entries.EntryStoreId = candidates.EntryStoreId
        <isNotNull property="joinWorkspaces">
           AND entries.Workspace IN
           <iterate property="joinWorkspaces" open="(" close=")" conjunction=",">
               #joinWorkspaces[]#
           </iterate>
        </isNotNull>
        <!-- This join to "categories" pulls all of the search categories for the entries -->
         INNER JOIN EntryCategory categories
            ON categories.EntryStoreId = candidates.EntryStoreId
           AND (
                    categories.Scheme != #collection#
                 OR categories.Term = aggregateEntryIds.AggregateEntryId
               )
        <!-- And, of course, we order by UpdateTimestamp to get them in the proper order, and by
             AggregateEntryId to make sure that components of the same Aggregate are grouped
             together (because it is possible for two aggregates to have the same UpdateTimestamp
             -->
         ORDER BY aggregateEntryIds.UpdateTimestamp, aggregateEntryIds.AggregateEntryId
    </select>

    <!-- This query return entries to be inserted in the AggregateFeedTimestamp table
     for a given feed, scheme and locale. It is also used for update a subset of the entries. -->
    <sql id="SELECT_AggregateEntriesForCache">
          SELECT
                 #cachedfeedid# AS CachedFeedId,
                 recentlyChangedEntries.Term AS AggregateEntryId,
                 recentlyChangedEntries.UpdateTimestamp
            FROM (
                 SELECT Term, UpdateTimestamp FROM vw_EntryWithCategory <include refid="WITH_NOEXPAND"/>
                 WHERE Scheme = #collection#
            ) recentlyChangedEntries
            INNER JOIN
                 (
                 SELECT siblings.Term,
                        MAX(siblings.UpdateTimestamp) AS MaxUpdateTimestamp
                 <isNotNull property="language">
                 , MAX(siblings.LanCode) AS LanCode
                 </isNotNull>

                 FROM vw_EntryWithCategory siblings  <include refid="WITH_NOEXPAND"/>

                 WHERE siblings.Scheme = #collection#

                 <isNotNull property="terms">
                  <!-- This parameter terms is used to select cached feed timestamps for a specific cached feed and terms
                      It is used for rebuilding a subset of the cached timestamps on category removal -->
                     AND siblings.Term IN
                    <iterate property="terms" open="(" close=")" conjunction=",">
                        #terms[]#
                    </iterate>
                 </isNotNull>

                 <isNotNull property="language">
                 AND ((siblings.LanCode = #language# AND siblings.CountryCode = #country#)
                        OR (siblings.LanCode = '**' AND siblings.CountryCode = '**'))
                 </isNotNull>

                 <isNotNull property="joinWorkspaces">
                 AND siblings.Workspace IN
                    <iterate property="joinWorkspaces" open="(" close=")" conjunction=",">
                      #joinWorkspaces[]#
                    </iterate>
                 </isNotNull>

                 GROUP BY siblings.Term

             ) matchingSiblingEntries

             ON recentlyChangedEntries.Term = matchingSiblingEntries.Term
             AND recentlyChangedEntries.UpdateTimestamp = matchingSiblingEntries.MaxUpdateTimestamp

             <isNotNull property="language">
             AND #language# = matchingSiblingEntries.LanCode
             </isNotNull>
    </sql>

  
  <!-- This query is used to update the cache table when an entry is added or updated -->
    <update id="updateTimestamp">
        UPDATE AggregateFeedTimestamp
           SET UpdateTimestampValue = #timestamp#
         WHERE
          <!-- 1. multiple updates -->
          <isNotNull property="feedterms">
            <iterate property="feedterms" open="(" close=")" conjunction="OR">
              CachedFeedId = #feedterms[].cachedFeedId# AND
              Term = #feedterms[].term#
            </iterate>
          </isNotNull>
         <!-- 2. single update -->
          <isNull property="feedterms">
            CachedFeedId = #cachedfeedid# AND
            Term = #term#
          </isNull>
          <!-- note: the clause below is to avoid update conflicts/deadlocks -->
          <isNotNull property="timestamp">
            AND UpdateTimestampValue &lt; #timestamp#
          </isNotNull>
    </update>


    <insert id="insertTimestamp" >
      INSERT INTO AggregateFeedTimestamp
        ( cachedFeedId, Term, UpdateTimestampValue)
      VALUES
        (#cachedfeedid#, #term#, #timestamp#)
    </insert>


    <!-- Find existing terms for the given cached feeds (and terms) -->
    <select id="selectFeedIdTerms" resultClass="org.atomserver.cache.AggregateFeedTerm">
      SELECT
        CachedFeedId AS cachedFeedId,
        Term as term
      FROM AggregateFeedTimestamp <include refid="WITH_NOLOCK"/>
      WHERE
      <!-- 1. with feed id and term-list -->
         <!-- This clause filters existing terms that are subset of the given terms
          Since a given cached feed can have thousands of terms, so this limit the amount of returned data
          to the given set. -->
      <isNotNull property="feedterms">
          <iterate property="feedterms" conjunction="OR">
            CachedFeedId = #feedterms[].feedId# AND Term IN
            <iterate property="feedterms[].terms" open="(" close=")" conjunction=",">
                     #feedterms[].terms[]#
            </iterate>
          </iterate>
      </isNotNull>
      <!-- 2. With feed ids -->
      <isNotNull property="feedids">
          CachedFeedId IN
          <iterate property="feedids" open="(" close=")" conjunction=",">
          #feedids[]#
        </iterate>
      </isNotNull>
        <!-- Additional matching timestamp -->
        <!-- this clause filters the terms in feeds with the existing timestamp -->
      <isNotNull property="timestamp">
        AND UpdateTimestampValue = #timestamp#
      </isNotNull>
    </select>


    <!-- This query is used to insert into the cache a set of cache entries -->
    <insert id="insertAggregateFeedCache" >
        INSERT INTO AggregateFeedTimestamp
        <include refid="SELECT_AggregateEntriesForCache"/>
    </insert>


    <!-- This query is used to delete a set of cached time stamps from a feed -->
    <delete id="deleteAggregateFeedCache" >
        DELETE FROM AggregateFeedTimestamp
        <isNotNull property="cachedfeedid">
          WHERE CachedFeedId = #cachedfeedid#
        </isNotNull>
    </delete>


    <delete id="deleteAggregateFeedCacheByFeedIdTerm">
      DELETE FROM AggregateFeedTimestamp
        WHERE
        <iterate property="feedterms" open="(" close=")" conjunction="OR">
          CachedFeedId = #feedterms[].cachedFeedId# AND
          Term = #feedterms[].term#
        </iterate>
    </delete>

   <!-- Queries on CachedFeed table -->

    <!-- This query is used by the Cache Manager during initialization to determine existing cache entries -->
    <select id="selectExistingCachedFeeds" resultClass="org.atomserver.cache.CachedAggregateFeed">
          SELECT CachedFeedId as cachedFeedId,
                 JoinedWorkspaces as orderedJoinedWorkspaces,
                 Locale as locale,
                 Scheme as scheme
            FROM CachedFeed <include refid="WITH_NOLOCK"/>
    </select>


    <!-- This query is used by the CacheManager during initialization to determine existing cache entries -->
    <insert id="insertCachedFeed">
          INSERT INTO CachedFeed ( CachedFeedId, JoinedWorkspaces, Locale, Scheme )
          <isEqual property="dbType" compareValue="hsql">
            VALUES (#cachedfeedid#, #workspaces#, #locale#, #scheme#)
          </isEqual>
          <isEqual property="dbType" compareValue="postgres">
            VALUES (#cachedfeedid#, #workspaces#, #locale#, #scheme#)
          </isEqual>
          <isEqual property="dbType" compareValue="sqlserver">
            VALUES (CAST(#cachedfeedid# as Uniqueidentifier), #workspaces#, #locale#, #scheme#)
          </isEqual>
    </insert>

    <select id="findCachedFeedById" resultClass="org.atomserver.cache.CachedAggregateFeed">
          SELECT CachedFeedId as cachedFeedId,
                 JoinedWorkspaces as orderedJoinedWorkspaces,
                 Locale as locale,
                 Scheme as scheme
            FROM CachedFeed  <include refid="WITH_NOLOCK"/>
            WHERE CachedFeedId = #cachedfeedid#
    </select>

    <delete id="deleteCachedFeedById" >
        DELETE FROM CachedFeed
          WHERE CachedFeedId = #cachedfeedid#
    </delete>

    <!-- ChangedEvents -->
  
    <select id="selectCacheConfigRevision" resultClass="java.lang.Long">
          SELECT ParamRevision
            FROM AppServerSysParam <include refid="WITH_NOLOCK"/>
            WHERE ParamName = #paramname#
    </select>

    <insert id="insertCacheConfigRevision">
          INSERT INTO AppServerSysParam
            (ParamName) VALUES (#paramname#)
     </insert>

     <update id="updateCacheConfigRevision">
          UPDATE AppServerSysParam
             SET ParamRevision = (Select ParamRevision + 1 From AppServerSysParam WHERE ParamName = #paramname# )
           WHERE ParamName = #paramname#
     </update>

</sqlMap>

