<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<!DOCTYPE sqlMap PUBLIC "-//iBATIS.com//DTD SQL Map 2.0//EN" "http://www.ibatis.com/dtd/sql-map-2.dtd">
<!--
 Copyright (c) 2007 HomeAway, Inc.
  All rights reserved.  http://www.atomserver.org

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->
<sqlMap>

    <sql id="aggregateEntries">
        <isNotNull property="language">
        SELECT L.Collection,
               L.EntryId,
               L.LanCode,
               L.CountryCode,
               MAX(N.UpdateTimestamp) AS UpdateTimestamp,
               MAX(N.UpdateDate) AS UpdateDate,
               MIN(N.CreateDate) AS CreateDate
          FROM VW_AggregateEntry L
               <isEqual property="dbType" compareValue="sqlserver" >WITH (NOEXPAND)</isEqual>
          JOIN VW_AggregateEntry N
               <isEqual property="dbType" compareValue="sqlserver" >WITH (NOEXPAND)</isEqual>
            ON L.Collection = N.Collection
           AND L.EntryId = N.EntryId
           AND L.LanCode = #language#
            <isNotNull property="country">
                <isEqual property="country" compareValue="">
           AND L.CountryCode = '**'
                </isEqual>
                <isNotEqual property="country" compareValue="">
           AND L.CountryCode = #country#
                </isNotEqual>
            </isNotNull>
            <isNull property="country">
           AND L.CountryCode = '**'
            </isNull>
            AND (N.LanCode = L.LanCode OR N.LanCode = '**')
            AND (N.CountryCode = L.CountryCode OR N.CountryCode = '**')
         WHERE L.Collection = #collection#
           AND N.UpdateTimestamp > #lastModifiedSeqNum#
        GROUP BY L.Collection, L.EntryId, L.LanCode, L.CountryCode
        </isNotNull>

        <isNull property="language">
        SELECT A.Collection,
               A.EntryId,
               '**' AS LanCode,
               '**' AS CountryCode,
               MAX(A.UpdateTimestamp) AS UpdateTimestamp,
               MAX(A.UpdateDate) AS UpdateDate,
               MIN(A.CreateDate) AS CreateDate
        FROM VW_AggregateEntry A
             <isEqual property="dbType" compareValue="sqlserver" >WITH (NOEXPAND)</isEqual>
        WHERE A.Collection = #collection#
          AND A.UpdateTimestamp > #lastModifiedSeqNum#
        GROUP BY A.Collection, A.EntryId
        </isNull>
    </sql>

    <sql id="SELECT_modifiedAggregateEntryIds">
        SELECT
        <include refid="paginationPrefix"/>
               AggregateEntry.EntryId AS EntryId
          FROM (
                <include refid="aggregateEntries"/>
               ) AggregateEntry
        <isNotNull property="categoryQuerySql">
         INNER JOIN ( $categoryQuerySql$ ) matchedEntry
            ON AggregateEntry.EntryId = matchedEntry.EntryId
        </isNotNull>
        <include refid="paginationSuffix"/>
    </sql>

    <select id="countModifiedAggregateEntries" parameterClass="map" resultClass="int">
        SELECT COUNT(EntryId) AS entryCount
          FROM (<include refid="SELECT_modifiedAggregateEntryIds"/>)
    </select>

    <select id="selectAggregateEntriesByPage" parameterClass="map" resultMap="entryResult">
        SELECT matchingSiblingEntriesAgainData.EntryStoreId AS EntryStoreId,
               matchingSiblingEntriesAgainData.Workspace AS Workspace,
               matchingSiblingEntriesAgainData.Collection AS Collection,
               matchingSiblingEntriesAgainData.LanCode AS LanCode,
               matchingSiblingEntriesAgainData.CountryCode AS CountryCode,
               matchingSiblingEntriesAgainData.EntryId AS EntryId,
               matchingSiblingEntriesAgainData.UpdateDate AS UpdateDate,
               matchingSiblingEntriesAgainData.CreateDate AS CreateDate,
             <isEqual property="dbType" compareValue="sqlserver">
               CONVERT(BIGINT, matchingSiblingEntriesAgainData.UpdateTimestamp) AS UpdateTimestamp,
             </isEqual>
             <isNotEqual property="dbType" compareValue="sqlserver">
               matchingSiblingEntriesAgainData.UpdateTimestamp AS UpdateTimestamp,
             </isNotEqual>
               matchingSiblingEntriesAgainData.DeleteFlag AS DeleteFlag,
               matchingSiblingEntriesAgainData.RevisionNum AS RevisionNum,
               infoCategoriesAgain.Scheme AS Scheme,
               infoCategoriesAgain.Term AS Term,
               infoCategoriesAgain.Term AS Label
          FROM
        (
        SELECT <include refid="paginationPrefix"/>
               recentlyChangedEntries.Term AS AggregateEntryId,
               recentlyChangedEntries.UpdateTimestamp
               <!-- 1. This first join here gets all the Entries that have been modified since the minTimestamp, and by joining-->
               <!--    on EntryCategory we only get Entries that can participate in the aggregate. Since there is an index-->
               <!--    on EntryStore.UpdateTimestamp, Sql Server will scan the index forward from the minTimestamp.-->
          FROM vw_EntryWithCategory recentlyChangedEntries
         <include refid="INNER_LOOP_JOIN"/> vw_EntryWithCategory matchingSiblingEntries <include refid="WITH_NOEXPAND"/>
               <!-- 1. This first set of constraints gets all entries that have been modified since the minTimestamp that also-->
               <!--    match the join scheme. Since VW_EntryWithCategory has an index of Scheme, UpdateTimestamp and Term it will-->
               <!--    scan the index forward from the minTimestamp.-->
            ON recentlyChangedEntries.Scheme = #collection#
           AND recentlyChangedEntries.UpdateTimestamp > #lastModifiedSeqNum#
               <!-- 2. We join in the matching sibling entries by joining on the scheme and term. We also filter the -->
               <!--    matchingSiblingEntries to only get entries that either match the locale or have no locale. -->
               <!--    The reason for this is that the semantics of aggregate feeds state that an aggregate contains -->
               <!--    all entries that either match the locale or have no locale AS LONG AS at least one sub-entry matches the -->
               <!--    locale. The 'as long as' piece is handled in the GROUP BY below.-->
           AND matchingSiblingEntries.Scheme = #collection#
           AND matchingSiblingEntries.Term = recentlyChangedEntries.Term
        <isNotNull property="language">
           AND ((matchingSiblingEntries.LanCode = #language# AND matchingSiblingEntries.CountryCode = #country#)
                OR (matchingSiblingEntries.LanCode = '**' AND matchingSiblingEntries.CountryCode = '**'))
        </isNotNull>
        <isNotNull property="joinWorkspaces">
         INNER JOIN EntryStore w ON w.EntryStoreId = matchingSiblingEntries.EntryStoreId AND
               w.Workspace IN
            <iterate property="joinWorkspaces" open="(" close=")" conjunction=",">#joinWorkspaces[]#</iterate>
        </isNotNull>
               <!-- 3. This final join gets all of the categories for all of the siblings, as we return those in each sub-entry-->
               <!--    of an aggregate feed. Note that at this point we are done EXCEPT for the following cases:-->
               <!--    3.1. As stated in #2 above, we need to get rid of cases where all the sub-entries in an aggregate are-->
               <!--         non localized (i.e. they all have '**' lanCode and countryCode).-->
               <!--    3.2. We need to run the category filter to only get aggregates that match the category-->
               <!--    3.3. In cases where 2 sub-entries belonging to the same aggregate have both been modified since -->
               <!--         minTimestamp, right now we'll get 2 aggregate entry results even though both of these aggregates -->
               <!--         contain the same sub-entries. The semantics of aggregate feeds dictate that we only want to get a -->
               <!--         single aggregate whose ordered position in the feed is dictated by the most recent change to any of-->
               <!--         the sub-entries.-->
         INNER JOIN EntryCategory infoCategories
            ON infoCategories.EntryStoreId = matchingSiblingEntries.EntryStoreId
               <!-- each set of rows belonging to the same aggregate entry will have the same scheme and term, and the-->
               <!-- UpdateTimestamp is the timestamp of the "triggering" subentry in the aggregate that was modified.-->
         GROUP BY recentlyChangedEntries.Scheme, recentlyChangedEntries.UpdateTimestamp, recentlyChangedEntries.Term
               <!-- 4. This having clause is where we filter out the items described in #3 above.-->
               <!--    4.1 If all of the sibling entries in a single aggregate have a lanCode of '**', then this first-->
               <!--        constraint gets rid of them.-->
        HAVING recentlyChangedEntries.UpdateTimestamp = MAX(matchingSiblingEntries.UpdateTimestamp)
        <isNotNull property="language">
        AND #language# = MAX(matchingSiblingEntries.LanCode)
        </isNotNull>
               <!--    4.2 This next constraint is how category constraints are implemented. Basically it ensures that-->
               <!--        at least one category row in each aggregate matches the constraint. This can be extended to-->
               <!--        support any AND/OR boolean logic by grouping successive SUM(...) > 0 clauses. Note, though,-->
               <!--        that this implementation causes an important change in the semantics of category constraints.-->
               <!--        See the notes below in the general comments.-->
        <isNotNull property="categoryQuerySql">$categoryQuerySql$</isNotNull>
               <!--    4.3 This final constraint deals with the situation described in 3.3 above-->
        <include refid="paginationSuffix"/>
        ) aggregateEntryIds
               <!-- 5. At this point we've determined the aggregate entries to pull - now we need to re-pull all of the-->
               <!--    sibling entries and info categories that we just filtered out in the GROUP BY above to get the full-->
               <!--    data set we need to return-->
         INNER JOIN vw_EntryWithCategory matchingSiblingEntriesAgain <include refid="WITH_NOEXPAND"/>
            ON matchingSiblingEntriesAgain.Scheme = #collection#
           AND matchingSiblingEntriesAgain.Term = aggregateEntryIds.AggregateEntryId
        <isNotNull property="language">
           AND ((matchingSiblingEntriesAgain.LanCode = #language# AND matchingSiblingEntriesAgain.CountryCode = #country#)
                OR (matchingSiblingEntriesAgain.LanCode = '**' AND matchingSiblingEntriesAgain.CountryCode = '**'))
        </isNotNull>
         INNER JOIN EntryStore matchingSiblingEntriesAgainData
            ON matchingSiblingEntriesAgainData.EntryStoreId = matchingSiblingEntriesAgain.EntryStoreId
        <isNotNull property="joinWorkspaces">
           AND matchingSiblingEntriesAgainData.Workspace IN
            <iterate property="joinWorkspaces" open="(" close=")" conjunction=",">#joinWorkspaces[]#</iterate>
        </isNotNull>
         INNER JOIN EntryCategory infoCategoriesAgain
            ON infoCategoriesAgain.EntryStoreId = matchingSiblingEntriesAgain.EntryStoreId
           AND (infoCategoriesAgain.Scheme != #collection# OR infoCategoriesAgain.Term = aggregateEntryIds.AggregateEntryId)
         ORDER BY aggregateEntryIds.UpdateTimestamp
    </select>

    <select id="selectAggregateEntry" parameterClass="map" resultMap="entryResult">
        <include refid="SELECT_EntryStore_JOIN_EntryCategory"/>
        INNER JOIN EntryCategory joincat
           ON entry.EntryStoreId = joincat.EntryStoreId
          AND joincat.scheme = #collection#
          AND joincat.term = #entryId#
       <!-- if this is a localized entry, we want to pull in things that are in the proper locale,
            as well as things that are not localized at all -->
       <isNotNull property="language">
          AND (entry.LanCode = #language# OR entry.LanCode = '**')
           <isNotNull property="country">
               <isNotEqual property="country" compareValue="">
          AND (entry.CountryCode = #country# OR entry.CountryCode = '**')
               </isNotEqual>
               <isEqual property="country" compareValue="">
          AND (entry.CountryCode = '**')
               </isEqual>
           </isNotNull>
           <isNull property="country">
          AND (entry.CountryCode = '**')
           </isNull>
       </isNotNull>
       <!-- but, in the case of a localized entry, we only want to return an entry if there is at
            least one localized component in the proper locale - this clause executes that filter
            and causes an empty result set in that case -->
       <isNotNull property="language">
          AND joincat.term IN (SELECT c.term
                                 FROM EntryCategory c JOIN EntryStore e
                                   ON c.EntryStoreId = e.EntryStoreId
                                WHERE c.scheme = #collection#
                                  AND c.term = #entryId#
                                  AND e.LanCode = #language#
           <isNotNull property="country">
               <isNotEqual property="country" compareValue="">
                                  AND e.CountryCode = #country#
               </isNotEqual>
               <isEqual property="country" compareValue="">
                                  AND e.CountryCode = '**'
               </isEqual>
           </isNotNull>
           <isNull property="country">
                                  AND e.CountryCode = '**'
           </isNull>
                                GROUP BY c.term
           )
       </isNotNull>
        <isNotNull property="joinWorkspaces">
            AND entry.Workspace IN
            <iterate property="joinWorkspaces" open="(" close=")" conjunction=",">#joinWorkspaces[]#</iterate>
        </isNotNull>        
    </select>

</sqlMap>

