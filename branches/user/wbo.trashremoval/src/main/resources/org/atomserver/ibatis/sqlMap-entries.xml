<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<!DOCTYPE sqlMap
        PUBLIC "-//iBATIS.com//DTD SQL Map 2.0//EN"
        "http://www.ibatis.com/dtd/sql-map-2.dtd">
<!--
 Copyright (c) 2007 HomeAway, Inc.
  All rights reserved.  http://www.atomserver.org

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-->

<!--  iBatis SQL Map for EntryStore -->
<sqlMap>

    <sql id="selectFeedPageNorm">
        SELECT <include refid="paginationPrefix"/>
               entry.EntryStoreId AS EntryStoreId,
               entry.Workspace AS Workspace,
               entry.Collection AS Collection,
               entry.LanCode AS LanCode,
               entry.CountryCode AS CountryCode,
               entry.EntryId AS EntryId,
               entry.UpdateDate AS UpdateDate,
               entry.CreateDate AS CreateDate,
               CAST(UpdateTimestamp AS BIGINT) AS UpdateTimestamp,
               entry.DeleteFlag AS DeleteFlag,
               entry.RevisionNum AS RevisionNum,
               entry.ContentHashCode AS contentHashCode
          FROM EntryStore entry
        <isNotNull property="categoryQuerySql">
        <include refid="INNER_LOOP_JOIN"/> EntryCategory searchCategories
            ON searchCategories.EntryStoreId = entry.EntryStoreId
        <isNotNull property="categoryFilterSql">AND ($categoryFilterSql$)</isNotNull>
        </isNotNull>
         WHERE UpdateDate >= #updatedMin#
        <isNotNull property="updatedMax">
            <![CDATA[ AND UpdateDate < #updatedMax# ]]>
        </isNotNull>
           AND UpdateTimestamp > CAST($startIndex$ AS <include refid="timestampType"/>)
        <isNotEqual property="endIndex" compareValue="-1">
            AND UpdateTimestamp &lt;= CAST($endIndex$ AS <include refid="timestampType"/>)
        </isNotEqual>
        <isNotNull property="latencySeconds">
           AND (
            <isEqual property="dbType" compareValue="hsql">
             DATEDIFF('ss', UpdateDate, NOW()) >= $latencySeconds$
            </isEqual>
            <isEqual property="dbType" compareValue="sqlserver">
             DATEADD(s, -1 * $latencySeconds$, GETDATE()) >= UpdateDate
            </isEqual>
            <isEqual property="dbType" compareValue="postgres">
             NOW() - interval '$latencySeconds$ seconds' >= UpdateDate
            </isEqual>
            )
        </isNotNull>
           AND Workspace = '$workspace$'
        <isNotNull property="collection">
           AND Collection = '$collection$'
        </isNotNull>
        <isNotNull property="language">
           AND LanCode = '$language$'
            <isNotNull property="country">
           AND CountryCode = '$country$'
            </isNotNull>
        </isNotNull>
        <isNotNull property="categoryQuerySql">
           GROUP BY entry.EntryStoreId,
                 entry.Workspace,
                 entry.Collection,
                 entry.LanCode,
                 entry.CountryCode,
                 entry.EntryId,
                 entry.UpdateDate,
                 entry.CreateDate,
                 entry.UpdateTimestamp,
                 entry.DeleteFlag,
                 entry.RevisionNum,
                 entry.ContentHashCode
           HAVING $categoryQuerySql$
        </isNotNull>
        ORDER BY entry.UpdateTimestamp
        <include refid="paginationSuffix"/>
    </sql>

    <!-- The following query is to improve performance on SQL Server by reducing columns in
    GROUP BY-HAVING and joining with EntryStore using a SQL server query join hint. -->
    <sql id="selectFeedPageSqlserver" >
        SELECT 
               entry.EntryStoreId AS EntryStoreId,
               entry.Workspace AS Workspace,
               entry.Collection AS Collection,
               entry.LanCode AS LanCode,
               entry.CountryCode AS CountryCode,
               entry.EntryId AS EntryId,
               entry.UpdateDate AS UpdateDate,
               entry.CreateDate AS CreateDate,
               CAST(UpdateTimestamp AS BIGINT) AS UpdateTimestamp,
               entry.DeleteFlag AS DeleteFlag,
               entry.RevisionNum AS RevisionNum,
               entry.ContentHashCode AS contentHashCode
          FROM (
          SELECT <include refid="paginationPrefix"/>
              entry.EntryStoreId
              FROM entryStore entry
              <isNotNull property="categoryQuerySql">
              <include refid="INNER_LOOP_JOIN"/> EntryCategory searchCategories
                  ON searchCategories.EntryStoreId = entry.EntryStoreId
              <isNotNull property="categoryFilterSql">AND ($categoryFilterSql$)</isNotNull>
              </isNotNull>
               WHERE UpdateDate >= #updatedMin#
              <isNotNull property="updatedMax">
                  <![CDATA[ AND UpdateDate < #updatedMax# ]]>
              </isNotNull>
                 AND UpdateTimestamp > CAST($startIndex$ AS <include refid="timestampType"/>)
              <isNotEqual property="endIndex" compareValue="-1">
                  AND UpdateTimestamp &lt;= CAST($endIndex$ AS <include refid="timestampType"/>)
              </isNotEqual>
              <isNotNull property="latencySeconds">
                 AND (
                   DATEADD(s, -1 * $latencySeconds$, GETDATE()) >= UpdateDate
                  )
              </isNotNull>
                 AND Workspace = '$workspace$'
              <isNotNull property="collection">
                 AND Collection = '$collection$'
              </isNotNull>
              <isNotNull property="language">
                 AND LanCode = '$language$'
                  <isNotNull property="country">
                 AND CountryCode = '$country$'
                  </isNotNull>
              </isNotNull>
              GROUP BY entry.EntryStoreId,
                       entry.UpdateTimestamp
              <isNotNull property="categoryQuerySql">HAVING $categoryQuerySql$</isNotNull>
                ORDER BY entry.UpdateTimestamp <include refid="paginationSuffix"/>
       ) matchEntries
       <!-- having an inner loop join here is important for performance -->
       <include refid="INNER_LOOP_JOIN"/> EntryStore entry
       ON entry.EntryStoreId = matchEntries.EntryStoreId
       ORDER BY entry.Updatetimestamp
     </sql>
  
    <select id="selectFeedPage" parameterClass="map" resultMap="entryResultSansCategories">
      <isEqual property="dbType"  compareValue="sqlserver">
        <isNotNull property="categoryQuerySql">
          <include refid="selectFeedPageSqlserver"/>
        </isNotNull>
        <isNull property="categoryQuerySql">
          <include refid="selectFeedPageNorm"/>
        </isNull>
      </isEqual>
      <isNotEqual property="dbType" compareValue="sqlserver">
        <include refid="selectFeedPageNorm"/>
      </isNotEqual>
    </select>

    <!-- SELECT the EntryStoreId for an entry by it's 5-tuple key -->
    <select id="selectEntryInternalId" parameterClass="map" resultClass="int">
        SELECT entry.EntryStoreId AS EntryStoreId
          FROM EntryStore entry
         WHERE Workspace=#workspace#
           AND Collection=#collection#
           AND LanCode=#language#
           AND CountryCode=#country#
           AND EntryId=#entryId#
    </select>

    <select id="selectCategoriesForEntries" parameterClass="map" resultMap="entryCategoryResult">
        SELECT EntryStore.EntryStoreId AS EntryStoreId,
               Workspace,
               Collection,
               EntryId,
               Scheme,
               Term,
               Label
          FROM EntryCategory JOIN EntryStore On EntryCategory.EntryStoreId = EntryStore.EntryStoreId
         WHERE Workspace = #workspace#
           AND Collection = #collection#
           AND EntryId IN
           <iterate property="entryIds" open="(" close=")" conjunction=",">#entryIds[]#</iterate>
    </select>

    <sql id="SELECT_EntryStore_JOIN_EntryCategory">
        <!-- this fragment encapsulates selecting the relevant columns from the EntryStore and
             EntryCategory tables when pulling back entries, whether retrieving a single Entry or
             an entire Feed -->
        SELECT entry.EntryStoreId AS EntryStoreId,
               entry.Workspace AS Workspace,
               entry.Collection AS Collection,
               entry.LanCode AS LanCode,
               entry.CountryCode AS CountryCode,
               entry.EntryId AS EntryId,
               entry.UpdateDate AS UpdateDate,
               entry.CreateDate AS CreateDate,
               CAST(entry.UpdateTimestamp AS BIGINT) AS UpdateTimestamp,
               entry.DeleteFlag AS DeleteFlag,
               entry.RevisionNum AS RevisionNum,
               entry.ContentHashCode as ContentHashCode,
               cat.Scheme AS Scheme,
               cat.Term AS Term,
               cat.Label AS Label
          FROM EntryStore entry
          LEFT OUTER JOIN EntryCategory cat
            ON entry.EntryStoreId = cat.EntryStoreId
    </sql>

    <select id="selectEntryByInternalId" parameterClass="map" resultMap="entryResult">
        <!-- SELECT a single Entry when we already know its primary key -->
        <include refid="SELECT_EntryStore_JOIN_EntryCategory"/>
        WHERE entry.EntryStoreId = CAST(#internalId# AS int)
    </select>

    <select id="selectEntry" parameterClass="map" resultMap="entryResult">
        <!-- SELECT a single Entry based on the 5-tuple key -->
        <include refid="SELECT_EntryStore_JOIN_EntryCategory"/>
        WHERE entry.Workspace=#workspace#
          AND entry.Collection=#collection#
          AND entry.LanCode=#language#
          AND entry.CountryCode=#country#
          AND entry.EntryId=#entryId#
    </select>

    <select id="selectEntries" parameterClass="map" resultMap="entryResult">
        <!-- SELECT all the entries that match some part of the 5-tuple key -->
        <include refid="SELECT_EntryStore_JOIN_EntryCategory"/>
        WHERE entry.Workspace=#workspace#
        <dynamic>
            <isNotNull property="collection">
                AND entry.Collection=#collection#
            </isNotNull>
            <isNotNull property="entryId">
                AND entry.EntryId=#entryId#
            </isNotNull>
            <isNotNull property="language">
                AND LanCode=#language#
            </isNotNull>
            <isNotNull property="country">
                AND CountryCode=#country#
            </isNotNull>
        </dynamic>
    </select>

    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <select id="selectEntryBatch" parameterClass="map" resultMap="entryResult">
        <!-- SELECT a batch of specific Entries from the DB based on the 5-tuple keys -->
        <include refid="SELECT_EntryStore_JOIN_EntryCategory"/>
        WHERE entry.Workspace=#workspace#
          AND entry.Collection=#collection#
          AND LanCode=#language#
          AND CountryCode=#country#
          AND entry.EntryId IN
        <iterate property="entryIds" open="(" close=")" conjunction=",">#entryIds[]#</iterate>
          ORDER BY UpdateTimestamp ASC
    </select>

    <select id="selectEntriesByLastModified" parameterClass="map" resultMap="entryResult">
        <!-- SELECT the entries that were last modified since the given time -->
        <include refid="SELECT_EntryStore_JOIN_EntryCategory"/>
        WHERE UpdateDate >= #updatedMin#
          AND entry.Workspace = #workspace#
        <isNotNull property="collection">
          AND entry.Collection=#collection#
        </isNotNull>
        ORDER BY UpdateDate
    </select>

    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <select id="selectEntriesByLastModifiedSeqNum" parameterClass="map" resultMap="entryResult">
        <include refid="SELECT_EntryStore_JOIN_EntryCategory"/>
        WHERE UpdateDate >= #updatedMin#
          AND entry.Workspace = #workspace#
        <isNotNull property="collection">
          AND entry.Collection=#collection#
        </isNotNull>
        ORDER BY UpdateTimestamp
    </select>

    <select id="countEntriesTotal" parameterClass="map" resultClass="int">
        SELECT COUNT(*) as entrycount FROM EntryStore
         WHERE Workspace = #workspace#
        <isNotNull property="collection">
            AND Collection=#collection#
        </isNotNull>
    </select>

    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <select id="countEntriesByLastModified" parameterClass="map" resultClass="int">
        <![CDATA[
        SELECT COUNT(*) as entrycount FROM EntryStore
         WHERE UpdateDate >= #updatedMin#
           AND Workspace = #workspace#
        ]]>
        <isNotNull property="collection">
            AND Collection=#collection#
        </isNotNull>
    </select>

    <select id="selectMaxIndex" parameterClass="map" resultClass="long">
        SELECT CAST(MAX(entry.UpdateTimestamp) AS BIGINT) AS UpdateTimestamp
          FROM EntryStore entry
        <isNotNull property="latencySeconds">
         WHERE (
            <isEqual property="dbType" compareValue="hsql">
             DATEDIFF('ss', UpdateDate, NOW()) >= $latencySeconds$
            </isEqual>
            <isEqual property="dbType" compareValue="sqlserver">
             DATEADD(s, -1 * $latencySeconds$, GETDATE()) >= UpdateDate
            </isEqual>
            <isEqual property="dbType" compareValue="postgres">
             NOW() - interval '$latencySeconds$ seconds' >= UpdateDate
            </isEqual>
            )
            <isNotNull property="updatedMax">
                <![CDATA[ AND UpdateDate < #updatedMax# ]]>
            </isNotNull>
        </isNotNull>
        <isNull property="latencySeconds">
            <isNotNull property="updatedMax">
                <![CDATA[ WHERE UpdateDate < #updatedMax# ]]>
            </isNotNull>
        </isNull>
    </select>

</sqlMap>

